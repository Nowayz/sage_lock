// sage_lock.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <Windows.h>
#include <Windowsx.h>
#include <initguid.h>
#include <ntddstor.h>
#include <hidusage.h>
#include <SetupAPI.h>
#include <Cfgmgr32.h>
#include <Hidclass.h>
#include <Hidsdi.h>
#include <hidusage.h>
#include <iostream>
#include <array>
#include <vector>
#include <string>
#include <iomanip>

#pragma comment(lib, "hid.lib")
#pragma comment(lib, "SetupAPI.lib")

typedef ULONG(WINAPI* RtlNtStatusToDosErrorFunc)(NTSTATUS Status);
std::string GetNtStatusErrorMessage(NTSTATUS ntstatus)
{
	// Load ntdll.dll library and get RtlNtStatusToDosError function address
	static HMODULE hNtDll = LoadLibrary(L"ntdll.dll");
	static RtlNtStatusToDosErrorFunc RtlNtStatusToDosError = (RtlNtStatusToDosErrorFunc)GetProcAddress(hNtDll, "RtlNtStatusToDosError");

	// Convert NTSTATUS to error code
	DWORD errorcode = RtlNtStatusToDosError(ntstatus);

	// Get error message from error code
	char lpBuffer[256];
	FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
		NULL, errorcode, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
		lpBuffer, sizeof(lpBuffer), NULL);

	return lpBuffer;
}

std::string GetLastErrorAsString()
{
	DWORD errorMessageID = ::GetLastError();
	if (errorMessageID == 0) {
		return std::string("No error"); //No error message has been recorded
	}

	char lpBuffer[256];
	size_t size = FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
		NULL, errorMessageID, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), lpBuffer, sizeof(lpBuffer), NULL);

	return lpBuffer;
}

void DisableTouchScreens()
{
	HDEVINFO deviceInfoSet = SetupDiGetClassDevs(&GUID_DEVINTERFACE_HID, NULL, NULL, DIGCF_DEVICEINTERFACE | DIGCF_PRESENT);
	if (deviceInfoSet == INVALID_HANDLE_VALUE) {
		std::cout << "SetupDiGetClassDevs " << GetLastErrorAsString() << std::endl;
		return;
	}

	SP_DEVICE_INTERFACE_DATA deviceInterfaceData;
	ZeroMemory(&deviceInterfaceData, sizeof(deviceInterfaceData));
	deviceInterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);

	for (DWORD i = 0; SetupDiEnumDeviceInterfaces(deviceInfoSet, NULL, &GUID_DEVINTERFACE_HID, i, &deviceInterfaceData); i++)
	{
		DWORD requiredSize = 0;
		SetupDiGetDeviceInterfaceDetail(deviceInfoSet, &deviceInterfaceData, NULL, 0, &requiredSize, NULL);

		PSP_DEVICE_INTERFACE_DETAIL_DATA detailData = (PSP_DEVICE_INTERFACE_DETAIL_DATA)LocalAlloc(LMEM_FIXED, requiredSize);
		if (detailData == NULL)
			continue;

		detailData->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);
		SP_DEVINFO_DATA devInfoData;
		ZeroMemory(&devInfoData, sizeof(devInfoData));
		devInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

		if (SetupDiGetDeviceInterfaceDetail(deviceInfoSet, &deviceInterfaceData, detailData, requiredSize, NULL, &devInfoData))
		{
			HANDLE deviceHandle = CreateFile(detailData->DevicePath, GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_FLAG_OVERLAPPED, NULL);
			if (deviceHandle != INVALID_HANDLE_VALUE)
			{
				PHIDP_PREPARSED_DATA preparsedData;
				HIDP_CAPS caps;
				if (HidD_GetPreparsedData(deviceHandle, &preparsedData) == TRUE)
				{
					if (HidP_GetCaps(preparsedData, &caps) != HIDP_STATUS_SUCCESS) {
						std::cout << "HidP_GetCaps " << GetLastErrorAsString() << std::endl;
					}
					if (caps.UsagePage == HID_USAGE_PAGE_DIGITIZER) // filter for digitizers
					{
						CONFIGRET cr;
						// get string with deviceid 
						WCHAR deviceId[MAX_DEVICE_ID_LEN];
						if ((cr = CM_Get_Device_ID(devInfoData.DevInst, deviceId, MAX_DEVICE_ID_LEN, 0)) != CR_SUCCESS) {
							std::cout << "CM_Get_Device_ID " << std::hex << std::setw(8) << std::setfill('0') << cr << std::endl;
						}
						// get string with device description
						WCHAR deviceDesc[4096];
						ULONG deviceDescSize = sizeof(deviceDesc);
						if ((cr = CM_Get_DevNode_Registry_Property(devInfoData.DevInst, CM_DRP_DEVICEDESC, NULL, deviceDesc, &deviceDescSize, 0)) != CR_SUCCESS) {
							std::cout << "CM_Get_DevNode_Registry_Property " << std::hex << std::setw(8) << std::setfill('0') << cr << std::endl;
						}
						
						// print device being disabled 
						wprintf(L"Disabling %s...\n", deviceDesc);
						// get dnDevInst of device and print
						DEVINST dnDevInst;
						dnDevInst = devInfoData.DevInst;
					getParents:;
						if ((cr = CM_Get_Parent(&dnDevInst, dnDevInst, 0)) != CR_SUCCESS) {
							std::cout << "CM_Get_Parent " << std::hex << std::setw(8) << std::setfill('0') << cr << std::endl;
							goto parentsDone;
						}
						std::cout << "dnDevInst: " << std::hex << std::setw(8) << std::setfill('0') << dnDevInst << std::endl;
						goto getParents;
					parentsDone:;

						// convert dnDevInst to DEVINSTID_W pDeviceID
						DEVINSTID_W pDeviceID = NULL;
						if ((cr = CM_Get_Device_IDW(dnDevInst, pDeviceID, MAX_DEVICE_ID_LEN, 0)) != CR_SUCCESS) {
							std::cout << "CM_Get_Device_IDW " << std::hex << std::setw(8) << std::setfill('0') << cr << std::endl;
						}
						
						// get handle to the dnDevInst
						HDEVINFO hDevInfo;
						SP_DEVINFO_DATA devInfoData;
						DWORD deviceInstanceHandle;
						hDevInfo = SetupDiCreateDeviceInfoList(NULL, NULL);
						devInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
						if ((cr = CM_Locate_DevNode(&deviceInstanceHandle, pDeviceID, 0)) != CR_SUCCESS) {
							std::cout << "CM_Locate_DevNode " << std::hex << std::setw(8) << std::setfill('0') << cr << std::endl;
						}
						// disable device
						if ((cr = CM_Disable_DevNode(deviceInstanceHandle, 0)) != CR_SUCCESS) {
							std::cout << "CM_Disable_DevNode " << std::hex << std::setw(8) << std::setfill('0') << cr << std::endl;
						}

					}
					HidD_FreePreparsedData(preparsedData);
				}
			}
			CloseHandle(deviceHandle);
		}
		LocalFree(detailData);
	}
	SetupDiDestroyDeviceInfoList(deviceInfoSet);
}


BOOL DisableDeviceByHidPath(const WCHAR* hidPath)
{
	// Get a handle to the device information set for all devices in the specified class
	HDEVINFO deviceInfoSet = SetupDiGetClassDevs(NULL, NULL, NULL, DIGCF_ALLCLASSES | DIGCF_PRESENT);

	if (deviceInfoSet == INVALID_HANDLE_VALUE)
	{
		std::cout << GetLastErrorAsString() << std::endl;
		return FALSE;
	}

	// Enumerate all devices in the device information set
	SP_DEVINFO_DATA deviceInfoData = { sizeof(SP_DEVINFO_DATA) };
	DWORD deviceIndex = 0;
	BOOL result = FALSE;

	while (SetupDiEnumDeviceInfo(deviceInfoSet, deviceIndex++, &deviceInfoData))
	{
		WCHAR deviceId[MAX_DEVICE_ID_LEN];
		if (CM_Get_Device_ID(deviceInfoData.DevInst, deviceId, MAX_DEVICE_ID_LEN, 0) != CR_SUCCESS)
		{
			std::cout << GetLastErrorAsString() << std::endl;
			continue;
		}

		// Check if the device has the specified HID path
		if (wcsstr(deviceId, hidPath) == NULL)
		{
			continue;
		}

		// Disable the device
		SP_PROPCHANGE_PARAMS propChangeParams = { sizeof(SP_PROPCHANGE_PARAMS) };
		propChangeParams.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
		propChangeParams.ClassInstallHeader.InstallFunction = DIF_PROPERTYCHANGE;
		propChangeParams.Scope = DICS_FLAG_GLOBAL;
		propChangeParams.StateChange = DICS_DISABLE;
		propChangeParams.HwProfile = 0;

		if (!SetupDiSetClassInstallParams(deviceInfoSet, &deviceInfoData, &propChangeParams.ClassInstallHeader, sizeof(propChangeParams)) ||
			!SetupDiCallClassInstaller(DIF_PROPERTYCHANGE, deviceInfoSet, &deviceInfoData))
		{
			std::cout << GetLastErrorAsString() << std::endl;
			continue;
		}

		result = TRUE;
		break;
	}

	SetupDiDestroyDeviceInfoList(deviceInfoSet);
	return result;
}


/////
// ToggleDevices takes a list of HID device paths and toggles the enabled state of each device
void ToggleDevices(std::vector<std::wstring> device_paths) {
	for (const auto& device_path : device_paths) {
		DEVINST dev_inst;
		CONFIGRET status = CM_Locate_DevNodeW(&dev_inst, (DEVINSTID_W)device_path.c_str(), CM_LOCATE_DEVNODE_NORMAL);
		if (status != CR_SUCCESS) {
			continue;
		}

		ULONG dev_status, dev_problem;
		status = CM_Get_DevNode_Status(&dev_status, &dev_problem, dev_inst, 0);
		if (status != CR_SUCCESS) {
			continue;
		}

		if (dev_status & DN_HAS_PROBLEM && dev_problem == CM_PROB_DISABLED) {
			CM_Enable_DevNode(dev_inst, 0);
		}
		else {
			CM_Disable_DevNode(dev_inst, 0);
		}
	}
}


std::array<DWORD, 4> Volume_Event_History{};
WORD Current_Index = 0;
DWORD64 Last_Volume_Event = 0;

// Check Volume_Event_History for UP DOWN UP DOWN events in the last 2 seconds
auto CheckForVolumeUpDownUpDown() {
	Current_Index = 0;
	return (Volume_Event_History[0] == VK_VOLUME_UP &&
			Volume_Event_History[1] == VK_VOLUME_DOWN &&
			Volume_Event_History[2] == VK_VOLUME_UP &&
			Volume_Event_History[3] == VK_VOLUME_DOWN);
}

// Get array index over 2 seconds of current time
auto GetAvailableKbdHistoryIndex() {
	auto dwCurrentTime = GetTickCount64();
	auto timeSinceLast = dwCurrentTime - Last_Volume_Event;
	Last_Volume_Event = dwCurrentTime;
	if ((timeSinceLast) > 500) {
		Current_Index = 0;
	} else {
		Current_Index++;
	}
	if (Current_Index > 3) {
		Current_Index = 0;
	}
	return Current_Index;
}

void SetKbdHistoryIndex(DWORD vkKey) {
	auto i = GetAvailableKbdHistoryIndex();
	//printf("[%i] %s\n", i, vkKey == VK_VOLUME_UP ? "VK_VOLUME_UP" : "VK_VOLUME_DOWN");
	Volume_Event_History[i] = vkKey;
	if ((i == 3) && CheckForVolumeUpDownUpDown()) {
		printf("Lock Toggle!\n");
	}
}

LRESULT CALLBACK pWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
	if (uMsg == WM_INPUT) {
		UINT dwSize = 0;
		GetRawInputData((HRAWINPUT)lParam, RID_INPUT, nullptr, &dwSize, sizeof(RAWINPUTHEADER));
		if (dwSize > 0) {
			static BYTE lpb[64];
			auto eventInfo = (RAWINPUT*)lpb;
			if (GetRawInputData((HRAWINPUT)lParam, RID_INPUT, lpb, &dwSize, sizeof(RAWINPUTHEADER)) == dwSize &&
				eventInfo->header.dwType         == RIM_TYPEKEYBOARD &&
				eventInfo->data.keyboard.Message == WM_KEYDOWN       &&
			   (eventInfo->data.keyboard.VKey    == VK_VOLUME_UP     ||
				eventInfo->data.keyboard.VKey    == VK_VOLUME_DOWN))
					SetKbdHistoryIndex(eventInfo->data.keyboard.VKey);
		}
	}
	return DefWindowProc(hWnd, uMsg, wParam, lParam);
}

DWORD WINAPI InputEventThread(LPVOID lpParameter) {
	static const wchar_t* winClassName = L"RECV_RAW_INPT";
	WNDCLASSEX wx = {};
	wx.cbSize = sizeof(WNDCLASSEX);
	wx.lpfnWndProc = pWndProc; // Callback to handle messages
	wx.hInstance = GetModuleHandle(NULL);
	wx.lpszClassName = winClassName;
	HWND hWnd = NULL;
	if (RegisterClassEx(&wx)) {
		hWnd = CreateWindowEx(0, winClassName, L"IOInptWin", 0, 0, 0, 0, 0, HWND_MESSAGE, NULL, NULL, NULL);
	}

	RAWINPUTDEVICE Rid[1]; // 1 = number of devices to listen to
	Rid[0].usUsagePage = HID_USAGE_PAGE_GENERIC;
	Rid[0].usUsage = HID_USAGE_GENERIC_KEYBOARD;
	Rid[0].dwFlags = RIDEV_INPUTSINK;
	Rid[0].hwndTarget = hWnd;
	RegisterRawInputDevices(Rid, 1, sizeof(Rid[0]));

	MSG msg;
	while (GetMessage(&msg, NULL, 0, 0)) {
		TranslateMessage(&msg);
		DispatchMessage(&msg);
	}
	return 0;
}

int main()
{
	//HANDLE hInputThread = CreateThread(NULL, NULL, InputEventThread, NULL, NULL, NULL);
	//WaitForSingleObject(hInputThread, INFINITE);

	// call to disable touch devices
	DisableTouchScreens();

	std::cin.get();
	return 0;

}

